# -*- coding: utf-8 -*-
"""IndustryDemand.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WcO1SLsQsBXy_fgpCqKdlD7_TsBKUCXD

# Industry energy demand

### Import necessary modules
"""

# Check if we are running the notebook directly, if so move workspace to parent dir
import sys
import os
currentdir = os.path.abspath(os.getcwd())
if os.path.basename(currentdir) != 'DemandMappingZambia':
  sys.path.insert(0, os.path.dirname(currentdir))
  os.chdir('..')
  print(f'Move to {os.getcwd()}')

### Activate geospatial_env first

# Numeric
import numpy as np
import pandas as pd

# System
import shutil
from IPython.display import display, Markdown, HTML, FileLink, FileLinks

# Spatial
import geopandas as gpd
from shapely.geometry import Point, Polygon, MultiPoint
from pyproj import CRS
from rasterstats import zonal_stats

# Plot
import matplotlib.pyplot as plt
import matplotlib.colors as colors
from matplotlib_scalebar.scalebar import ScaleBar

pd.options.display.float_format = '{:,.4f}'.format

from utils import processing_raster, finalizing_rasters, spatialjoinvectors

"""### Define directories and dataset names"""

### Define directories and dataset names
ROOT_DIR = os.path.abspath(os.curdir)
in_path = ROOT_DIR
out_path = ROOT_DIR + "/Outputs/"

## mines layer
ind_data_path = in_path + "/Industry/Data/"
mines_path = ind_data_path + "mines"
mines_name_output = 'mineral_facilities_zambia'
mines_name_input = 'Mineral_Facilities_correctedInput.csv'

## Coordinate and projection systems
crs_WGS84 = CRS("EPSG:4326")    # Originan WGS84 coordinate system
crs_proj = CRS("EPSG:32736")    # Projection system for the selected country -- see http://epsg.io/ for more info

"""### Define area of interest"""

try: area
except NameError: area = "COUNTRY"
# area = "Copperbelt"

"""### Import layers to be used"""

hexagons = gpd.read_file(out_path + "h3_grid_at_hex.shp")

grid = hexagons

## mines
# mines = gpd.read_file(mines_path + mines_name)

# ## admininstrative boundary
admin_gdf = gpd.read_file(ROOT_DIR + "/admin/" + "gadm41_ZMB.gpkg", layer='ADM_ADM_0')
region_gdf = gpd.read_file(ROOT_DIR + "/admin/" + "gadm41_ZMB.gpkg", layer='ADM_ADM_1')

# transmission lines
grid_gdf = gpd.read_file(ROOT_DIR + "/Grid/Zambia - HVLines/" + "HVLines.shp")

grid_gdf.head(2)

"""# Part 1. Extract GIS-based attributes

## Extract information from vector layers

Assess the energy consumption per site
"""

## Attribute energy consumption to each copper production site
mines_input_file = pd.read_csv(ind_data_path + mines_name_input)

## Running the energy calculation function
from Industry import energy_per_site

energy_per_site.calc_energy_per_site(mines_path, mines_input_file, mines_name_output)

"""Extract sum production of mines in each cluster (hex)"""

## Run the extraction
#grid.drop(['Commodity Production - tonne (tonnes)'], axis=1, inplace=True) ##uncomment if you want to rerun
# columnNameMines = "Commodity Production - tonne (tonnes)"
#columnNameMines = 'Ore processed (tonnes)'
# grid[columnNameMines] = grid[columnNameMines].fillna(0)
# grid.head(4)
# grid[columnNameMines].sum()

columnName_ElecConsumption = 'Elec_TJ'
columnName_OilConsumption = 'Diesel_TJ'
columnName_CopperElecConsumption = 'Copper_Elec_Cons_TJ'
file = os.path.join(mines_path, mines_name_output +".gpkg")
grid, mines = spatialjoinvectors("EnergyMines", columnName_ElecConsumption, admin_gdf, crs_WGS84, grid, "sum", file)
grid, mines_data = spatialjoinvectors(
        "Electricity Copper",
        columnName_CopperElecConsumption,
        admin_gdf, crs_WGS84, grid, "sum", file
    )

grid[columnName_ElecConsumption].sum()

grid[columnName_CopperElecConsumption].sum()

grid.head(2)

mines.head(2)

"""# Part 2. Compute demand"""

# Enegery balance from UN Stats
energyBalance_path = "EnergyBalance/"
file_energyBalance = "UNSD+DF_UNData_EnergyBalance+1.0_Zambia.csv"
eb = pd.read_csv(energyBalance_path + file_energyBalance)
code_elec = "B07_EL"
code_oil = "B03_OP"
code_ind_nFM=  "B29_1214a"
code_ind_mining =  "B33_1214e"

elec_nonFerrousMetals_TJ = eb.loc[(eb['COMMODITY'] == code_elec) & (eb['TRANSACTION'] == code_ind_nFM) & (eb['TIME_PERIOD'] == 2019 ), 'OBS_VALUE'] #TJ
elec_mining_TJ = eb.loc[(eb['COMMODITY'] == code_elec) & (eb['TRANSACTION'] == code_ind_mining) & (eb['TIME_PERIOD'] == 2019 ), 'OBS_VALUE'] #TJ
oil_nonFerrousMetals_TJ = eb.loc[(eb['COMMODITY'] == code_oil) & (eb['TRANSACTION'] == code_ind_nFM) & (eb['TIME_PERIOD'] == 2019 ), 'OBS_VALUE'] #TJ
oil_mining_TJ = eb.loc[(eb['COMMODITY'] == code_oil) & (eb['TRANSACTION'] == code_ind_mining) & (eb['TIME_PERIOD'] == 2019 ), 'OBS_VALUE'] #TJ

elec_nonFerrousMetals_TJ = pd.to_numeric(elec_nonFerrousMetals_TJ.str.replace(',', '')) # convert to numeric and remove commas
elec_nonFerrousMetals_TJ = elec_nonFerrousMetals_TJ.iloc[0]
elec_mining_TJ = pd.to_numeric(elec_mining_TJ.str.replace(',', '')) # convert to numeric and remove commas
elec_mining_TJ = elec_mining_TJ.iloc[0]
elec = elec_nonFerrousMetals_TJ+elec_mining_TJ
oil_nonFerrousMetals_TJ = pd.to_numeric(oil_nonFerrousMetals_TJ.str.replace(',', '')) # convert to numeric and remove commas
oil_nonFerrousMetals_TJ = oil_nonFerrousMetals_TJ.iloc[0]
oil_mining_TJ = pd.to_numeric(oil_mining_TJ.str.replace(',', '')) # convert to numeric and remove commas
oil_mining_TJ = oil_mining_TJ.iloc[0]
oil = oil_nonFerrousMetals_TJ+oil_mining_TJ

energy = elec+oil

print("total statistical electricity consumption of nonFerrousMetals:",f"{elec_nonFerrousMetals_TJ:,.1f}", "TJ")
print("total statistical electricity consumption in mining:",f"{elec_mining_TJ:,.1f}", "TJ")
print("total statistical electricity consumption of nonFerrousMetals and mining:",f"{elec:,.1f}", "TJ")

print("total statistical oil consumption of nonFerrousMetals:",f"{oil_nonFerrousMetals_TJ:,.1f}", "TJ")
print("total statistical oil consumption in mining:",f"{oil_mining_TJ:,.1f}", "TJ")
print("total statistical oil consumption of nonFerrousMetals and mining:",f"{oil:,.1f}", "TJ")

print("total statistical  energy consumption of nonFerrousMetals and mining:",f"{energy:,.1f}", "TJ")

elec_mining_consum = mines[mines["Output type (ass.)"].isin(["Ore and concentrate", "Metal in ore"])][columnName_ElecConsumption].sum()

# Assess total energy consumption and total production
total_elec_consum = mines[columnName_ElecConsumption].sum() # total
total_oil_consum = mines[columnName_OilConsumption].sum() # total
total_energy_consum = total_elec_consum + total_oil_consum
coverage_energy_nonFe_mining = total_energy_consum/energy
coverage_elec_nonFe_mining = total_elec_consum/elec
coverage_oil_nonFe_mining = total_oil_consum/oil

mines_mining = mines[mines["Output type (ass.)"].isin(["Ore and concentrate", "Metal in ore"])]
elec_mining_consum = mines_mining[columnName_ElecConsumption].sum()
oil_mining_consum = mines_mining[columnName_OilConsumption].sum()
mines_nonFerrous = mines[mines["Output type (ass.)"].isin(["Metal"])]
elec_nonFerrousMetals_consum = mines_nonFerrous[columnName_ElecConsumption].sum()
oil_nonFerrousMetals_consum = mines_nonFerrous[columnName_OilConsumption].sum()

# print("total production:", f"{total_production/10**3:,.0f}", "kt")
print("total calculated electricity ", f"{total_elec_consum:,.1f}",
      "(mining: ", f"{elec_mining_consum:,.1f}",", non-Fe: ",f"{elec_nonFerrousMetals_consum:,.1f}", ")")
print("total calculated diesel ", f"{total_oil_consum:,.1f}",
      "(mining: ",f"{oil_mining_consum:,.1f}",", non-Fe: ",f"{oil_nonFerrousMetals_consum:,.1f}", ")")
print("total calculated energy consumption:", f"{total_energy_consum:,.1f}", "TJ")
print("----------------------------------------------------------------------------------------")
print("Coverage energy in statistical nonFerrousMetals and mining consumption:", f"{coverage_energy_nonFe_mining*100:,.0f}", "%")
print("----------------------------------------------------------------------------------------")
print("Coverage electricity in statistical nonFerrousMetals and mining consumption:", f"{coverage_elec_nonFe_mining*100:,.0f}", "%")
print("Coverage fuel/oil in statistical nonFerrousMetals and mining consumption:", f"{coverage_oil_nonFe_mining*100:,.0f}", "%")
print("----------------------------------------------------------------------------------------")
print("Coverage electricity in statistical mining consumption:", f"{elec_mining_consum/elec_mining_TJ*100:,.0f}", "%")
print("Coverage fuel/oil in statistical mining consumption:", f"{oil_mining_consum/oil_mining_TJ*100:,.0f}", "%")
print("Coverage electricity in statistical nonFerrousMetals consumption:", f"{elec_nonFerrousMetals_consum/elec_nonFerrousMetals_TJ*100:,.0f}", "%")
print("Coverage fuel/oil in statistical nonFerrousMetals consumption:", f"{oil_nonFerrousMetals_consum/oil_nonFerrousMetals_TJ*100:,.0f}", "%")

#Allocate to each hexagon the industry energy consumption
#grid["IndEnergy"]=grid[columnNameMines]*energycons_perton
# adjust energy consumption if coverage is the whole country
if area == "COUNTRY":
    grid["IndEne_TJ"]=grid[columnName_ElecConsumption]/coverage_elec_nonFe_mining  # TJ
else:
    grid["IndEne_TJ"]=grid[columnName_ElecConsumption] # TJ
grid.head(3)

total_industryenergy = grid["IndEne_TJ"].sum()
#print("Industry electricity consumption:",f"{total_industryenergy/10**6:,.0f}", "TWh")
print("Industry electricity consumption in",f"{area}", ":",f"{total_industryenergy/3600:,.1f}", "TWh")

grid.to_file(out_path + 'ind_energy_map.shp', index=False)
grid.to_file(out_path + f'ind_energy_map.geojson', driver='GeoJSON', index=False)
grid.head(3)

grid[columnName_ElecConsumption]

"""# Part 3: Industry mapping"""

plt.rcParams.update({'font.size': 22})

# Retrieve copper values and convert in GWh
grid['Copper_elec_kWh'] = grid[columnName_CopperElecConsumption] / 3.6
totalperregion=grid.groupby('NAME_1')['Copper_elec_kWh'].sum()
grid['total_copper_elec_perregion'] = grid['NAME_1'].map(totalperregion)
totalperregion

grid_filtered = grid[grid['NAME_1'] == 'Copperbelt']
region_gdf_filtered = region_gdf[region_gdf['NAME_1'] == 'Copperbelt']
hexagons_filtered = hexagons[hexagons['NAME_1'] == 'Copperbelt']

# Plot the industry demand map per cell
# Create the axis first
fig, ax = plt.subplots(figsize=(25, 15))

# Plot data with a log scale value
grid_filtered.sort_values('Copper_elec_kWh', ascending=True).plot(
    ax=ax, column='Copper_elec_kWh', cmap="Reds", legend=True, alpha=0.9, norm=colors.LogNorm(vmin = 1, vmax=grid['Copper_elec_kWh'].max()),
    legend_kwds={"label": "Consumption in kWh"})

# # Plot data
# grid.sort_values('IndEnergy_GWh', ascending=True).plot(
#     ax=ax, column='IndEnergy_GWh', cmap="Reds", legend=True, alpha=0.5, vmin=0, vmax=threshold)

# # Plot data
# grid.sort_values('IndEnergy_GWh', ascending=True).plot(
#     ax=ax, column='IndEnergy_GWh', cmap="Reds", legend=True, alpha=0.9)

# admin_gdf.plot(ax=ax, edgecolor='brown', color='None', alpha=0.6)
region_gdf_filtered.plot(ax=ax, edgecolor='brown', color='None', alpha=0.2)
hexagons_filtered.plot(ax=ax, edgecolor='brown', color='None', alpha=0.2)
# lines_gdf.plot(ax=ax, edgecolor='brown', alpha=0.2)

# Compute the distance-per-pixel of the map
# see https://geopandas.org/en/latest/gallery/matplotlib_scalebar.html#Geographic-coordinate-system-(degrees)
# assert grid.crs == 'EPSG:4326'
# from shapely.geometry.point import Point
# points = gpd.GeoSeries(
#     [Point(-73.5, 40.5), Point(-74.5, 40.5)], crs=4326
# )  # Geographic WGS 84 - degrees
# points = points.to_crs(32619)  # Projected WGS 84 - meters
# distance_meters = points[0].distance(points[1])

# # Add a scale bar
# scalebar = ScaleBar(
#     distance_meters,
#     dimension="si-length",
#     location='lower left',
#     length_fraction=0.1,
#     width_fraction=0.001,
#     units='m',
#     color='black',
#     fixed_value=None
# )

# # ax.set_aspect('equal', 'box')
# # txt = ax.set_title('Electricity in the mining sector in {} (GWh)'.format(area) )
# ax.add_artist(scalebar)
ax.set_axis_off()
# Save plot as figure
plt.savefig(out_path +'map_industry_copper_log.png', bbox_inches='tight')

# Plot the demand map with a log scale value
# Create the axis first
fig, ax = plt.subplots(figsize=(25, 15))

# Plot data
grid.sort_values('total_copper_elec_perregion', ascending=True).plot(
    ax=ax, column='total_copper_elec_perregion', cmap="Reds", legend=True, alpha=0.9,
    norm=colors.LogNorm(vmin = 1, vmax=grid['total_copper_elec_perregion'].max()),
    legend_kwds={"label": "Consumption in kWh"})

# # Plot data
# grid.sort_values('totalindeperregion', ascending=True).plot(
#     ax=ax, column='totalindeperregion', cmap="Reds", legend=True, alpha=0.5, vmin=0, vmax=threshold)

# # Plot data
# grid.sort_values('totalindeperregion', ascending=True).plot(
#     ax=ax, column='totalindeperregion', cmap="Reds", legend=True, alpha=0.9)
admin_gdf.plot(ax=ax, edgecolor='brown', alpha=0.05)
ax.set_aspect('equal', 'box')
# ax.set_title('Electricity in the copper sector in Zambia (GWh)')
ax.set_xlabel('Longitude')
ax.set_ylabel('Latitude')

from matplotlib.ticker import FuncFormatter

# fmt = lambda x, pos: '{:.1%}'.format(x)
# cbar = plt.colorbar(format=FuncFormatter(fmt))

# Save plot as figure
plt.savefig(out_path +'map_industry_copper_log_region.png', bbox_inches='tight')

