# -*- coding: utf-8 -*-
"""GeoDem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18phrEKVa5QlGpTwkaZWOFqstGSyMDnR0

# Geospatial demand estimation

**Original code:**  [Ariane Millot](https://github.com/ariane-millot), [Alexandros Korkovelos](https://github.com/akorkovelos) <br />
**Support:** [Martin J. Stringer](), [Andjelka Kerekes](), [Roberto Heredia]()<br />
**Funding:** Climate Compatible Growth Programme, Imperial College <br />

---------------------------

#### Brief overview

This notebook performs three main analytical processes:

- **Part 1**: Generated grid mesh (H3 hexagons) for the area of interest (given input admin boundary)
- **Part 2**: Extract GIS-based attributes (vecror or raster) to the grid
- **Part 3**: Build blocks estimating demand for the different energy vectors

A slightly more detailed description of the processing bits is presented before each part below. <br />

### Import necessary modules
"""

### Activate geospatial_env first

# Numeric
import numpy as np
import pandas as pd
import math

# System
import os

# Spatial
import geopandas as gpd


# Mapping / Plotting
import matplotlib.pyplot as plt
from matplotlib.colors import LogNorm
import matplotlib.colors as colors
from matplotlib.ticker import MaxNLocator
from matplotlib_scalebar.scalebar import ScaleBar
import seaborn as sns

import config

# Utility and Data Loading Modules
from utils import processing_raster, finalizing_rasters, spatialjoinvectors
from data_loader import load_initial_data

pd.options.display.float_format = '{:,.2f}'.format

"""# Part 1. Create base grid with H3"""

# Commented out IPython magic to ensure Python compatibility.
# %run basegridhex.py

"""# Part 2. Extract GIS-based attributes

## Extract information from vector layers
"""

regions, admin_gdf, region_gdf, grid = load_initial_data(config)

# transmission lines
mv_lines_gdf = gpd.read_file(config.MV_LINES_SHP)
hv_lines_gdf = gpd.read_file(config.HV_LINES_SHP)

 # # Define line types and their specific buffer distances
 #    lines_to_process = [
 #        {'name': 'HV Lines', 'gdf': hv_lines_gdf, 'buffer_dist': app_config.HV_LINES_BUFFER_DIST},
 #        {'name': 'MV Lines', 'gdf': mv_lines_gdf, 'buffer_dist': app_config.MV_LINES_BUFFER_DIST}
 #    ]

MV_O_lines_gdf = gpd.read_file(config.GRID_PATH / "Zambia - Distribution MV Overhead Line/" + "Zambia - Distribution MV Overhead Line.shp")
MV_O_lines_gdf = gpd.clip(MV_O_lines_gdf, admin_gdf)
MV_U_lines_gdf = gpd.read_file(config.GRID_PATH / "Zambia - Distribution MV Underground Line/" + "Distribution_Medium_Voltage_Underground_Line_Network_neww.shp")
MV_U_lines_gdf = gpd.clip(MV_U_lines_gdf, admin_gdf)

"""# Part 3. Constructing Multi-vector Demand

### Calculate Total Demand

**Demand = Residential + Commercial + Industrial **

where,

**Residential** = No of HH with access X average en. cons. kWh/HH/year

**Commercial**  = Number of employee X average en. con. kWh/employee

**Industrial**  = Commodity Production (tonnes) from mines X average energy consumption per tonne
"""

# Commented out IPython magic to ensure Python compatibility.
# %run Buildings/building_demand.ipynb

total_residential_electricity_assessed = grid[config.COL_RES_ELEC_KWH_METH2].sum()
print("residential electricity consumption:", f"{total_residential_electricity_assessed/10**6:,.0f}","GWh") # GWh

# Commented out IPython magic to ensure Python compatibility.
# %run Industry/industry_demand.ipynb
print("Industry electricity consumption in",f"{area}",f"{total_industry_electricity_tj/3600:,.1f}", "TWh")

# Concatenate results
out_path = config.OUTPUT_DIR
grid_buildings = gpd.read_file(config.BUILDINGS_GPKG_FILE) # contains services and residential data
grid_industry = gpd.read_file(config.INDUSTRY_GPKG_FILE)

grid = grid_buildings.copy()
grid = grid.merge(grid_industry, on='id', suffixes=('', '_y'))
grid.drop(grid.filter(regex='_y$').columns, axis=1, inplace=True)
grid.head(2)

# Units
grid[config.COL_IND_ELEC_GWH]=grid[config.COL_IND_ELEC_TJ]/3.6
grid[config.COL_IND_ELEC_KWH]=grid[config.COL_IND_ELEC_GWH]/10**6
total_ind_electricity_gwh = grid[config.COL_IND_ELEC_GWH].sum()
print(f"Industry: {total_ind:,.0f}", "GWh")
grid[config.COL_RES_ELEC_KWH_FINAL] = grid[config.COL_RES_ELEC_KWH_METH2_SCALED]
total_res_electricity_gwh = grid[config.COL_RES_ELEC_KWH_FINAL].sum() / 10**6
print(f"Residential: {total_res_electricity_gwh:,.0f}", "GWh")
total_ser_electricity_gwh = grid[config.COL_SER_ELEC_KWH_FINAL].sum() / 10**6
print(f"Services: {total_ser_electricity_gwh:,.0f}", "GWh")

grid[config.COL_TOTAL_ELEC_KWH] = grid.apply(lambda row: (np.nansum([row[config.COL_RES_ELEC_KWH_FINAL],
                                          row[config.COL_SER_ELEC_KWH_FINAL],
                                             row[config.COL_IND_ELEC_KWH]
                                                     ])), axis=1)
total_elec_gwh = grid[config.COL_TOTAL_ELEC_KWH].sum() / 10**6
print("total electricity consumption:", f"{total:,.0f}","GWh")

grid.head(3)

"""### Export result"""

grid.to_file(out_path + 'total_eletricity_consumption_grid.gpkg', driver="GPKG", index=False, engine='fiona')
#grid.to_file(out_path + 'total_demand_grid.geojson', driver="GeoJSON")
# grid.to_file(out_path + f'total_demand.geojson', driver='GeoJSON', index=False)

"""## Print maps for quick assessment"""

plt.rcParams.update({'font.size': 22})

"""### Total demand map"""

# # Plot the demand map with use of the full scale
# # Create the axis first
# fig, ax = plt.subplots(figsize=(10, 15))

# # Plot data
# grid.sort_values('TotalDem_GWh', ascending=True).plot(
#     ax=ax, column='TotalDem_GWh', cmap="Reds", legend=True, alpha=0.5)

# ax.set_aspect('equal', 'box')
# txt = ax.set_title('Electricity in {} (kWh)'.format(area) )

# # Save plot as figure
# plt.savefig(out_path +'total_elec_demand_map.png', bbox_inches='tight')

# # Plot the demand map with a threshold value
# # Create the axis first
# # fig, ax = plt.subplots(figsize=(25, 15))
# fig, ax = plt.subplots(figsize=(15, 10))

# # Set the threshold
# # threshold = np.percentile(npgrid['TotalDem'], 90)
# threshold = 0.1 * grid['TotalDemGWh'].max()

# # Plot data
# grid.sort_values('TotalDem_GWh', ascending=True).plot(
#     ax=ax, column='TotalDem_GWh', cmap="Reds", legend=True, alpha=0.5, vmin=0, vmax=threshold)

# ax.set_aspect('equal', 'box')
# txt = ax.set_title('Electricity in {} (kWh)'.format(area) )

# # Save plot as figure
# plt.savefig(out_path +'total_demand_elec_map_threshold.png', bbox_inches='tight')

# Plot the demand map with a log scale value
# Create the axis first
fig, ax = plt.subplots(figsize=(25, 15))
# Add latitude and longitude labels
ax.set_xlabel('Longitude (°)')
ax.set_ylabel('Latitude (°)')

# Plot data
grid.sort_values('TotalDem_kWh', ascending=True).plot(
    ax=ax, column='TotalDem_kWh', cmap="Reds", legend=True, alpha=0.9, norm=colors.LogNorm(vmin = 1, vmax=grid['TotalDem_kWh'].max()),
    legend_kwds={"label": "Consumption in kWh"})

admin_gdf.plot(ax=ax, edgecolor='brown', color='None', alpha=0.6)
region_gdf.plot(ax=ax, edgecolor='brown', color='None', alpha=0.2)

ax.set_aspect('equal', 'box')
txt = ax.set_title('Electricity in {} (kWh)'.format(area) )

# Compute the distance-per-pixel of the map
# see https://geopandas.org/en/latest/gallery/matplotlib_scalebar.html#Geographic-coordinate-system-(degrees)
# assert grid.crs == 'EPSG:4326'
from shapely.geometry.point import Point
points = gpd.GeoSeries(
    [Point(-73.5, 40.5), Point(-74.5, 40.5)], crs=4326
)  # Geographic WGS 84 - degrees
points = points.to_crs(32619)  # Projected WGS 84 - meters
distance_meters = points[0].distance(points[1])

# Add a scale bar
scalebar = ScaleBar(
    distance_meters,
    dimension="si-length",
    location='lower left',
    length_fraction=0.1,
    width_fraction=0.001,
    units='m',
    color='black',
    fixed_value=None
)

ax.add_artist(scalebar)

# Save plot as figure
plt.savefig(out_path +'total_demand_elec_log.png', bbox_inches='tight')

"""### Residential map"""

# Plot the demand map with a log scale value
# Create the axis first
fig, ax = plt.subplots(figsize=(25, 15))

# Add latitude and longitude labels
ax.set_xlabel('Longitude (°)')
ax.set_ylabel('Latitude (°)')

# Plot data
grid.sort_values('REnS_kWh', ascending=True).plot(
    ax=ax, column='REnS_kWh', cmap="Reds", legend=True, alpha=0.9, norm=colors.LogNorm(vmin = 1, vmax=grid['REnS_kWh'].max()),
    legend_kwds={"label": "Consumption in kWh"}) #, "orientation": "horizontal"})

admin_gdf.plot(ax=ax, edgecolor='brown', color='None', alpha=0.6)
region_gdf.plot(ax=ax, edgecolor='brown', color='None', alpha=0.2)
# transmission lines
lines_gdf.plot(ax=ax, edgecolor='purple', color='purple', alpha=0.4)
# MV_lines_gdf.plot(ax=ax, edgecolor='purple', color='purple', alpha=0.05)

ax.set_aspect('equal', 'box')
# txt = ax.set_title('Electricity consumption in the residential sector in {} (kWh)'.format(area) )
# txt = ax.set_title('Electricity consumption in the residential sector (kWh)' )

# print(grid.crs)

# Compute the distance-per-pixel of the map
# see https://geopandas.org/en/latest/gallery/matplotlib_scalebar.html#Geographic-coordinate-system-(degrees)
# assert grid.crs == 'EPSG:4326'
from shapely.geometry.point import Point
points = gpd.GeoSeries(
    [Point(-73.5, 40.5), Point(-74.5, 40.5)], crs=4326
)  # Geographic WGS 84 - degrees
points = points.to_crs(32619)  # Projected WGS 84 - meters
distance_meters = points[0].distance(points[1])

# Add a scale bar
scalebar = ScaleBar(
    distance_meters,
    dimension="si-length",
    location='lower left',
    length_fraction=0.1,
    width_fraction=0.001,
    units='m',
    color='black',
    fixed_value=None
)

ax.add_artist(scalebar)

# Save plot as figure
plt.savefig(out_path +'map_residential_log.png', bbox_inches='tight')

"""### Services map"""

# Plot the demand map with a log scale value
# Create the axis first
fig, ax = plt.subplots(figsize=(25, 15))
# Add latitude and longitude labels
ax.set_xlabel('Longitude (°)')
ax.set_ylabel('Latitude (°)')


# Plot data
grid.sort_values('SEn_kWh', ascending=True).plot(
    ax=ax, column='SEn_kWh', cmap="Reds", legend=True, alpha=0.9, norm=colors.LogNorm(vmin = 1, vmax=grid['SEn_kWh'].max()),
    legend_kwds={"label": "Consumption in kWh"})
admin_gdf.plot(ax=ax, edgecolor='brown', color='None', alpha=0.6)
region_gdf.plot(ax=ax, edgecolor='brown', color='None', alpha=0.2)
# transmission lines
lines_gdf.plot(ax=ax, edgecolor='purple', color='purple', alpha=0.4)

# # Plot data
# grid.sort_values('TotalDem', ascending=True).plot(
#     ax=ax, column='TotalDem', cmap="Reds", legend=True, alpha=0.5, vmin=0, vmax=threshold)

# # Plot data
# grid.sort_values('TotalDem', ascending=True).plot(
#     ax=ax, column='TotalDem', cmap="Reds", legend=True, alpha=0.9)

# Compute the distance-per-pixel of the map
# see https://geopandas.org/en/latest/gallery/matplotlib_scalebar.html#Geographic-coordinate-system-(degrees)
# assert grid.crs == 'EPSG:4326'
from shapely.geometry.point import Point
points = gpd.GeoSeries(
    [Point(-73.5, 40.5), Point(-74.5, 40.5)], crs=4326
)  # Geographic WGS 84 - degrees
points = points.to_crs(32619)  # Projected WGS 84 - meters
distance_meters = points[0].distance(points[1])

# Add a scale bar
scalebar = ScaleBar(
    distance_meters,
    dimension="si-length",
    location='lower left',
    length_fraction=0.1,
    width_fraction=0.001,
    units='m',
    color='black',
    fixed_value=None
)
ax.set_aspect('equal', 'box')
# txt = ax.set_title('Electricity in the services sector in {} (kWh)'.format(area) )
# txt = ax.set_title('Electricity in the services sector (GWh)')

ax.add_artist(scalebar)
# Save plot as figure
plt.savefig(out_path +'map_services_log.png', bbox_inches='tight')

"""### Buildings map"""

grid['Bui_GWh'] = grid['SEn_GWh']+grid['REnS_GWh']
grid['Bui_kWh'] = grid['SEn_kWh']+grid['REnS_kWh']

# Plot the demand map with a log scale value
# Create the axis first
# sns.set_theme('poster')
# sns.set_style('white')
fig, ax = plt.subplots(figsize=(25, 15))
# Add latitude and longitude labels
ax.set_xlabel('Longitude (°)')
ax.set_ylabel('Latitude (°)')


# Plot data
grid.sort_values('Bui_kWh', ascending=True).plot(
    ax=ax, column='Bui_kWh', cmap="Reds", legend=True, alpha=0.9, norm=colors.LogNorm(vmin = 1, vmax=grid['Bui_kWh'].max()),
    legend_kwds={"label": "Consumption in kWh"})
admin_gdf.plot(ax=ax, edgecolor='brown', color='None', alpha=0.6)
region_gdf.plot(ax=ax, edgecolor='brown', color='None', alpha=0.2)
# transmission lines
lines_gdf.plot(ax=ax, edgecolor='purple', color='purple', alpha=0.4)

# Compute the distance-per-pixel of the map
# see https://geopandas.org/en/latest/gallery/matplotlib_scalebar.html#Geographic-coordinate-system-(degrees)
# assert grid.crs == 'EPSG:4326'
from shapely.geometry.point import Point
points = gpd.GeoSeries(
    [Point(-73.5, 40.5), Point(-74.5, 40.5)], crs=4326
)  # Geographic WGS 84 - degrees
points = points.to_crs(32619)  # Projected WGS 84 - meters
distance_meters = points[0].distance(points[1])

# Add a scale bar
scalebar = ScaleBar(
    distance_meters,
    dimension="si-length",
    location='lower left',
    length_fraction=0.1,
    width_fraction=0.001,
    units='m',
    color='black',
    fixed_value=None
)
ax.set_aspect('equal', 'box')
# txt = ax.set_title('Electricity in buildings in {} (kWh)'.format(area) )
# txt = ax.set_title('Electricity in buildings (GWh)')

ax.add_artist(scalebar)
# Save plot as figure
plt.savefig(out_path +'map_buildings_log.png', bbox_inches='tight')

"""### Industry map"""

# Plot the industry demand map per cell
# Create the axis first
fig, ax = plt.subplots(figsize=(25, 15))

# Plot data with a log scale value
grid.sort_values('IndEnergy_kWh', ascending=True).plot(
    ax=ax, column='IndEnergy_kWh', cmap="Reds", legend=True, alpha=0.9, norm=colors.LogNorm(vmin = 1, vmax=grid['IndEnergy_kWh'].max()),
    legend_kwds={"label": "Consumption in kWh"})

# # Plot data
# grid.sort_values('IndEnergy_GWh', ascending=True).plot(
#     ax=ax, column='IndEnergy_GWh', cmap="Reds", legend=True, alpha=0.5, vmin=0, vmax=threshold)

# # Plot data
# grid.sort_values('IndEnergy_GWh', ascending=True).plot(
#     ax=ax, column='IndEnergy_GWh', cmap="Reds", legend=True, alpha=0.9)

admin_gdf.plot(ax=ax, edgecolor='brown', color='None', alpha=0.6)
region_gdf.plot(ax=ax, edgecolor='brown', color='None', alpha=0.2)
# lines_gdf.plot(ax=ax, edgecolor='brown', alpha=0.2)

# Compute the distance-per-pixel of the map
# see https://geopandas.org/en/latest/gallery/matplotlib_scalebar.html#Geographic-coordinate-system-(degrees)
# assert grid.crs == 'EPSG:4326'
from shapely.geometry.point import Point
points = gpd.GeoSeries(
    [Point(-73.5, 40.5), Point(-74.5, 40.5)], crs=4326
)  # Geographic WGS 84 - degrees
points = points.to_crs(32619)  # Projected WGS 84 - meters
distance_meters = points[0].distance(points[1])

# Add a scale bar
scalebar = ScaleBar(
    distance_meters,
    dimension="si-length",
    location='lower left',
    length_fraction=0.1,
    width_fraction=0.001,
    units='m',
    color='black',
    fixed_value=None
)

ax.set_aspect('equal', 'box')
# txt = ax.set_title('Electricity in the mining sector in {} (GWh)'.format(area) )
ax.add_artist(scalebar)
# Save plot as figure
plt.savefig(out_path +'map_industry_log.png', bbox_inches='tight')

(grid['IndEnergy_GWh'] != 0).sum()

(grid['IndEnergy_GWh'] > 50).sum()

totalperregion=grid.groupby('NAME_1')['IndEnergy_GWh'].sum()
totalperregion

grid['totalindeperregion'] = grid['NAME_1'].map(totalperregion)

# Plot the demand map with a log scale value
# Create the axis first
fig, ax = plt.subplots(figsize=(25, 15))

# Plot data
grid.sort_values('totalindeperregion', ascending=True).plot(
    ax=ax, column='totalindeperregion', cmap="Reds", legend=True, alpha=0.9, norm=colors.LogNorm(vmin = 1, vmax=grid['totalindeperregion'].max()))

# # Plot data
# grid.sort_values('totalindeperregion', ascending=True).plot(
#     ax=ax, column='totalindeperregion', cmap="Reds", legend=True, alpha=0.5, vmin=0, vmax=threshold)

# # Plot data
# grid.sort_values('totalindeperregion', ascending=True).plot(
#     ax=ax, column='totalindeperregion', cmap="Reds", legend=True, alpha=0.9)
admin_gdf.plot(ax=ax, edgecolor='brown', alpha=0.05)
ax.set_aspect('equal', 'box')
ax.set_title('Electricity in the mining sector in Zambia (GWh)')
ax.set_xlabel('Longitude')
ax.set_ylabel('Latitude')

from matplotlib.ticker import FuncFormatter

# fmt = lambda x, pos: '{:.1%}'.format(x)
# cbar = plt.colorbar(format=FuncFormatter(fmt))

# Save plot as figure
plt.savefig(out_path +'map_log_ind.png', bbox_inches='tight')

